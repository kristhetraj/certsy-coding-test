<html>
  <head>
    <script src="https://unpkg.com/konva@8.3.12/konva.min.js"></script>
    <style>
      #container {
        background-color: grey;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>

    <script>
      var stage = new Konva.Stage({
        container: 'container', // id of container <div>
        width: 1000,
        height: 500,
      });
      var layer = new Konva.Layer();
      stage.add(layer);

      const gridSize = 50;

      const leftWall = 100;
      const topWall = 100;
      const noGridTiles = 6;
      const rightWall = leftWall + noGridTiles * gridSize;
      const bottomWall = topWall + noGridTiles * gridSize;

      var instructionText = new Konva.Text({
        x: rightWall,
        y: topWall - 50,
        text: '[Instructions]\n\nTop arrow = forward\nBack arrow = backward\nLeft arrow = rotate left\nRight arrow = rotate right\nSpace bar = Report',
        fontSize: 18,
        fontFamily: 'Calibri',
        fill: 'black',
        width: 300,
        padding: 20,
        align: 'center',
      });
      layer.add(instructionText);

      var commandText = new Konva.Text({
        x: rightWall,
        y: topWall + 100,
        text: '[Commands]\n\n',
        fontSize: 18,
        fontFamily: 'Calibri',
        fill: 'black',
        width: 300,
        padding: 20,
        align: 'center',
      });
      layer.add(commandText);

      const commands = [];
      const addCommand = (command) => {
        commands.push(command);
        // console.log('commands', commands);
        const commandTextStr = commands
          .slice(commands.length - Math.min(10, commands.length))
          .reduce((acc, curr) => {
            return `${acc}\n${curr}`;
          }, '[Commands]\n\n');
        commandText.text(commandTextStr);
      };

      var table = new Konva.Rect({
        x: leftWall,
        y: topWall,
        width: noGridTiles * gridSize,
        height: noGridTiles * gridSize,
        fill: 'green',
        stroke: 'black',
        strokeWidth: 1,
      });
      layer.add(table);

      var obstruction;
      const renderObstruction = () => {
        obstruction = new Konva.Rect({
          x: leftWall + gridSize,
          y: topWall + gridSize,
          width: gridSize,
          height: gridSize,
          fill: 'blue',
          stroke: 'black',
          strokeWidth: 1,
        });
        layer.add(obstruction);
      };
      renderObstruction();

      const bodyRadius = gridSize / 2;
      var robotBody = new Konva.Circle({
        x: leftWall + gridSize / 2,
        y: topWall + gridSize / 2,
        radius: gridSize / 2,
        fill: 'red',
        stroke: 'black',
        strokeWidth: 1,
      });
      layer.add(robotBody);

      const headRadius = (1 / 8) * gridSize;
      var robotHead = new Konva.Circle({
        x: robotBody.x() + gridSize / 4,
        y: robotBody.y(),
        radius: headRadius,
        fill: 'pink',
        stroke: 'black',
        strokeWidth: 1,
      });
      layer.add(robotHead);

      let direction = 'EAST';

      const moveHeadDirection = (newDirection) => {
        direction = newDirection;
        switch (direction) {
          case 'EAST':
            robotHead.x(robotBody.x() + gridSize / 4);
            robotHead.y(robotBody.y());
            break;
          case 'WEST':
            robotHead.x(robotBody.x() - gridSize / 4);
            robotHead.y(robotBody.y());
            break;
          case 'NORTH':
            robotHead.x(robotBody.x());
            robotHead.y(robotBody.y() - gridSize / 4);
            break;
          case 'SOUTH':
            robotHead.x(robotBody.x());
            robotHead.y(robotBody.y() + gridSize / 4);
            break;
        }
      };

      const move = (moveDirection = 'FORWARD') => {
        let commandStr = '';
        if (moveDirection === 'FORWARD') {
          commandStr += 'move forward: ';
        } else {
          commandStr += 'move backward: ';
        }
        // move EAST

        const getObstructionCheckOkay = (nextBodyPosX, nextBodyPosY) => {
          const obstructionX = obstruction.x();
          const obstructionY = obstruction.y();

          const obstructionCheckOkay =
            nextBodyPosX < obstructionX ||
            nextBodyPosX > obstructionX + gridSize ||
            nextBodyPosY < obstructionY ||
            nextBodyPosY > obstructionY + gridSize;

          return obstructionCheckOkay;
        };

        if (
          (direction === 'EAST' && moveDirection === 'FORWARD') ||
          (direction === 'WEST' && moveDirection === 'BACKWARD')
        ) {
          const nextBodyPosX = robotBody.x() + gridSize;
          const nextBodyPosY = robotBody.y();
          // wall check
          const wallCheckOkay = nextBodyPosX < rightWall;
          // obstructioncheck
          const obstructionCheckOkay = getObstructionCheckOkay(
            nextBodyPosX,
            nextBodyPosY
          );
          // console.log('obstructionCheckOkay', { nextBodyPos, obsX: obstruction.x( });
          if (wallCheckOkay && obstructionCheckOkay) {
            commandStr += 'success';
            robotBody.x(nextBodyPosX);
            robotHead.x(robotHead.x() + gridSize);
          } else {
            commandStr += 'fail';
          }
        }
        // move WEST
        else if (
          (direction === 'WEST' && moveDirection === 'FORWARD') ||
          (direction === 'EAST' && moveDirection === 'BACKWARD')
        ) {
          const nextBodyPosX = robotBody.x() - gridSize;
          const nextBodyPosY = robotBody.y();
          // wall check
          const wallCheckOkay = nextBodyPosX > leftWall;
          // obstructioncheck
          const obstructionCheckOkay = getObstructionCheckOkay(
            nextBodyPosX,
            nextBodyPosY
          );
          if (wallCheckOkay && obstructionCheckOkay) {
            commandStr += 'success';
            robotBody.x(nextBodyPosX);
            robotHead.x(robotHead.x() - gridSize);
          } else {
            commandStr += 'fail';
          }
        }
        // move NORTH
        else if (
          (direction === 'NORTH' && moveDirection === 'FORWARD') ||
          (direction === 'SOUTH' && moveDirection === 'BACKWARD')
        ) {
          const nextBodyPosX = robotBody.x();
          const nextBodyPosY = robotBody.y() - gridSize;

          // wall check
          const wallCheckOkay = nextBodyPosY > topWall;
          // obstructioncheck
          const obstructionCheckOkay = getObstructionCheckOkay(
            nextBodyPosX,
            nextBodyPosY
          );
          if (wallCheckOkay && obstructionCheckOkay) {
            commandStr += 'success';
            robotBody.y(nextBodyPosY);
            robotHead.y(robotHead.y() - gridSize);
          } else {
            commandStr += 'fail';
          }
        }
        // move SOUTH
        else if (
          (direction === 'SOUTH' && moveDirection === 'FORWARD') ||
          (direction === 'NORTH' && moveDirection === 'BACKWARD')
        ) {
          const nextBodyPosX = robotBody.x();
          const nextBodyPosY = robotBody.y() + gridSize;

          // wall check
          const wallCheckOkay = nextBodyPosY < bottomWall;
          // obstructioncheck
          const obstructionCheckOkay = getObstructionCheckOkay(
            nextBodyPosX,
            nextBodyPosY
          );
          if (wallCheckOkay && obstructionCheckOkay) {
            commandStr += 'success';
            robotBody.y(nextBodyPosY);
            robotHead.y(robotHead.y() + gridSize);
          } else {
            commandStr += 'fail';
          }
        }
        addCommand(commandStr);
      };

      var container = stage.container();
      container.tabIndex = 1;
      container.focus();
      container.addEventListener('keydown', function (e) {
        // console.log(e.keyCode);
        if (e.keyCode === 32) {
          // SPACE BAR
          addCommand(
            `direction: ${direction}, x: ${
              robotBody.x() - leftWall - bodyRadius
            }, y:${robotBody.y() - topWall - bodyRadius}`
          );
        }
        if (e.keyCode === 37) {
          // LEFT ARROW
          addCommand('rotate left');
          switch (direction) {
            case 'EAST':
              moveHeadDirection('NORTH');
              break;
            case 'WEST':
              moveHeadDirection('SOUTH');
              break;
            case 'NORTH':
              moveHeadDirection('WEST');
              break;
            case 'SOUTH':
              moveHeadDirection('EAST');
              break;
          }
        } else if (e.keyCode === 38) {
          // UP ARROW
          move();
        } else if (e.keyCode === 39) {
          // RIGHT ARROW
          addCommand('rotate right');
          switch (direction) {
            case 'EAST':
              moveHeadDirection('SOUTH');
              break;
            case 'WEST':
              moveHeadDirection('NORTH');
              break;
            case 'NORTH':
              moveHeadDirection('EAST');
              break;
            case 'SOUTH':
              moveHeadDirection('WEST');
              break;
          }
        } else if (e.keyCode === 40) {
          move('BACKWARD');
          // DOWN ARROW
        } else {
          return;
        }
        e.preventDefault();
      });

      layer.draw();
    </script>
  </body>
</html>
